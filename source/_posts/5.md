---
title: CNN：CV、边缘检测、卷积运算、Padding、Stride、filter
categories: 机器学习
tags: 机器学习
mathjax: true
date: 2018-05-24 18:49:04
---

## Computer Vision(CV)

CV 是深度学习应用的主要方向之一。CV 问题主要包括以下三类：
1. Image Classification
2. Object detection
3. Neural Style Transfer

## 传统神经网络为什么不能够很好的胜任 CV 问题？

主要的原因就是 CV 问题通常输入层的维度很大，比如一张 $64 \times 64 \times 3$ 的图片，假设采用的是传统的全连接神经网络，隐藏层有 128 个神经元，那么权重矩阵 W 中将包含 1572864 个参数。如果图片尺寸更大的话，这个问题将更严重。参数太多会导致以下问题：

1. 需要更多的内存
2. 计算量很大
3. 容易过拟合

解决这一问题的方法就是使用卷积神经网络（CNN）。


## 对神经网络如何处理 CV 问题的理解

神经网络由浅层到深层，分别可以检测出图片的边缘特征 、局部特征（例如眼睛、鼻子等）、整体面部轮廓。

## 边缘检测（Edge Detection）

图片的边缘包含两类：**水平边缘**和**垂直边缘**，如下图所示。

![](/img/cnn_base1.png)

### 卷积计算过程

图片的边缘检测可以通过与相应滤波器进行卷积来实现。以垂直边缘检测为例，原始图片对应的尺寸为 $6 \times 6$，滤波器对应的尺寸为 $3 \times 3$，不对原始图片进行填充（padding），步长为 1。则卷积后的图片尺寸变为 $4 \times 4$，第 1 步的卷积过程如下：

$$
3 \times 1 + 0 \times 0 + 1 times (-1) + 1 \times 1 + 5 \times 0 + 8 \times (-1) + 2 \times 1 + 7 \times 0 + 2\times (-1) = -5。
$$

![](/img/cnn_base2.png)

第 2 步：

![](/img/cnn_base3.png)

第 3 步：

![](/img/cnn_base4.png)

第 4 步：

![](/img/cnn_base5.png)

第 5 步：

![](/img/cnn_base6.png)

最后 1 步：

![](/img/cnn_base7.png)

空白位置的值可以自行计算以下。另外说明我们使用 $*$ 表示卷积运算。

### 垂直方向的边缘检测

![](/img/cnn_base8.png)

### 水平方向的边缘检测

![](/img/cnn_base9.png)

### 图片边缘处的渐变方式

图片边缘有两种渐变方式，一种是由明变暗，另一种是由暗变明。以垂直边缘检测为例，下图展示了两种方式的区别。实际应用中，这两种渐变方式并不影响边缘检测结果，可以对输出图片取绝对值操作，得到同样的结果。

![](/img/cnn_base10.png)

### 常见的滤波器算子

垂直边缘检测和水平边缘检测的滤波器算子如下：

![](/img/cnn_base11.png)

增加图片中心区域权重的滤波器算子：

![](/img/cnn_base12.png)

## CNN 和 filter 的关系

在深度学习中，如果我们想检测图片的**各种边缘特征**，而不仅限于垂直边缘和水平边缘，那么filter的数值一般需要通过模型训练得到，类似于标准神经网络中的权重W一样由梯度下降算法反复迭代求得。CNN的主要目的就是计算出这些filter的数值。确定得到了这些filter后，CNN浅层网络也就实现了对图片所有边缘特征的检测。

## Padding

按照我们上面讲的图片卷积，如果原始图片尺寸为 $n \times n$，filter 尺寸为 $f \times f$，则卷积后的图片尺寸为 $(n-f+1) \times (n-f+1)$，注意 f 一般为奇数（过滤器的尺寸一般为奇数）。这样存在以下两个问题：

1. 卷积运算后，输出图片尺寸缩小
2. 原始图片边缘信息对输出贡献得少，输出图片丢失边缘信息

为了解决图片缩小的问题，可以使用padding方法，即把原始图片尺寸进行扩展，扩展区域补零，用p来表示每个方向扩展的宽度。

![](/img/cnn_base13.png)

经过 padding 之后，原始图片尺寸为 $(n+2p) \times (n + 2p)$，filter的尺寸为 $f \times f$，卷积后图片的尺寸为 $(n+2p-f+1) \times (n+2p-f+1)$。若要保证图片尺寸不变，则 p 应该满足：

$$
p = \frac{f-1}{2}
$$

没有 padding 操作，$p=0$，我们称之为 **Valid convolutions**，有 padding 操作，$p=\frac{f−1}{2}，我们称之为 **Same convolutions**。

## 步长（Stride）

Stride 表示 filter 在原图片中水平方向和垂直方向每次的步进长度。之前我们默认 $stride=1$。若 $stride=2$，则表示 filter 每次步进长度为 2，即隔一点移动一次。

![](/img/cnn_base14.png)

我们用 s 表示 stride 长度，p 表示 padding 长度，如果原始图片尺寸为 $n \times n$，filter 尺寸为 $f \times f$，则卷积后的图片尺寸为：
$$
\left \lfloor \frac{n+2p-f}{s} + 1 \right \rfloor \times \left \lfloor \frac{n+2p-f}{s} + 1 \right \rfloor
$$

## 相关系数和卷积

相关系数（cross-correlations）与卷积（convolutions）之间是有区别的。实际上，真正的卷积运算会先将filter绕其中心旋转180度，然后再将旋转后的filter在原始图片上进行滑动计算。比较而言，相关系数的计算过程则不会对filter进行旋转，而是直接在原始图片上进行滑动计算。其实，目前为止我们介绍的CNN卷积实际上计算的是相关系数，而不是数学意义上的卷积。但是，我们一般把CNN中的这种“相关系数”就称作卷积运算。之所以可以这么等效，是因为滤波器算子一般是水平或垂直对称的，180度旋转影响不大，而且最终滤波器算子需要通过CNN网络梯度下降算法计算得到，旋转部分可以看作是包含在CNN模型算法中。总的来说，忽略旋转运算可以大大提高CNN网络运算速度，而且不影响模型性能。其中filter旋转示意图如下：

![](/img/cnn_base15.png)

## 多通道上的卷积

对于3通道的RGB图片，其对应的滤波器算子同样也是3通道的。3通道图片的卷积运算与单通道图片的卷积运算基本一致。**过程是将每个单通道与对应的filter进行卷积运算求和，然后再将3通道的和相加，得到输出图片的一个像素值。**

不同通道的滤波器算子可以不相同。也就是说如果将一个三通道的滤波器算子看成三个单通道的滤波器算子，那个这三个滤波器算子不必相同。

![](/img/cnn_base16.png)

为了进行多个卷积运算，实现更多边缘检测，可以使用更多的滤波器算子。不同的滤波器算子通过卷积得到不同的输出。将这些输出组合起来就得到了最后的输出。

若输入图片的尺寸为 $n \times n \times nc$，filter 尺寸为 $n \times n \times nc$，并假设没有 padding，步长为 1，则卷积后的图片尺寸为 $(n-f+1) \times (n-f+1)\times nc$。也就是说“输出”对应的尺寸为 $(n-f+1) \times (n-f+1) \times {nc}'$，其中 $nc$ 为通道数，${nc}'$ 为滤波器算子的数目。

![](/img/cnn_base17.png)

## 参考
1. [吴恩达《卷积神经网络》精炼笔记（1）-- 卷积神经网络基础](https://mp.weixin.qq.com/s?__biz=MzIwOTc2MTUyMg==&mid=2247484005&idx=1&sn=2e40be17ad50cc4253a026c37910766a&chksm=976fa7f8a0182eee1fc5f8dde25a87a40f34eb6889cb0927e11f5ce1eaf5ced7fc42950f2b30&scene=21#wechat_redirect)
2. 深度学习工程师微专业 —— 吴恩达

