---
title: Java 面试总结（二）
categories: 编程
tags:
  - 编程
  - Java
date: 2019-03-22 08:35:08
---

### final 关键字

final 是 Java 的关键字，它所表示的是“这部分是无法修改的”。使用到 final 的有四种情况：变量、方法、类、参数。

- 修饰变量：编译时常量和运行时常量
- 修饰方法：final 关键字修饰的方法可以被继承，但是不能被重写
- 修饰类：如果某个类用 final 修饰，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中出于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类。  对于 final 修饰的类来说，它的成员变量可以为 final，也可以为非 final。如果定义为 final，那么 final 数据的规则同样适合它。而它的方法则会自动的加上 final，因为 final 类是无法被继承，所以这个是默认的。
- 修饰参数：若某个参数被 final 修饰了，则代表了该参数是不可改变的，final 修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为 final。

### static 关键字

static 关键字可以修饰变量、方法、代码块，被 static 修饰的变量和方法是属于类的。

- 变量：被 static 修饰的变量我们称之为静态变量，静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。
- 方法：被 static 修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用，static 方法必须实现，也就是说他不能是抽象方法（不能用 abstract 关键字来修饰）。
- 代码块：被 static 修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该类的任何地方。

使用 static 关键字还要注意以下几点：

- 静态方法中不能访问类的非静态成员变量和非静态成员方法，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量的。
- static 不允许修饰局部变量。
- 无论是变量、方法，还是代码块，只要用 static 修饰，就是在类被加载时就已经"准备好了"。非静态变量在 new 一个对象的时候才会初始化（可参考《Java编程思想》 95 页例子理解）。
- static 修饰的变量和方法都能被继承，但不能被“修改”，但都能够再次声明。

[参考](https://www.cnblogs.com/dolphin0520/p/3799052.html)

### 如何理解构造器实际上是静态方法？

假设有一个类名为 Dog 的类，首次创建 Dog 类的对象（或者 Dog 类的静态成员和静态方法被访问）的时候，Java 解释器必须查找类路径，定位 Dog.class 文件，然后载入 Dog.class。所以从这个角度去看的话，构造器实际上是静态方法。

### 请总结一下对象的创建过程？

可参考《Java编程思想》 96 页。

假设有一个类名为 Dog 的类，首次创建 Dog 类的对象（或者 Dog 类的静态成员和静态方法被访问）的时候，Java 解释器必须查找类路径，定位 Dog.class 文件，然后载入 Dog.class。接下来有关静态初始化的所有动作都会执行，因此静态初始化只在 Class 对象首次加载的时候执行一次。当用 new Dog() 创建对象的时候，首先将在堆上为 Dog 对象分配足够的存储空间。这块存储空间会被清零，这一步就自动将 Dog 对象中的所有基本数据类型都设置成了默认值，而引用被设置成了 null。接着执行所有出现于字段定义处的初始化动作（如果有父类的话，那么会先转去父类执行父类的出现于字段定义处的初始化动作，接着执行父类的构造器，依此类推），最后执行构造器。

### 默认初始值的问题？

类中的成员变量是有默认初始值的，如果是基本类型的变量会获得基本类型的标准初值，如果是对象引用，默认的初始值就是 null。而**方法中的局部变量则必须在使用之前赋值**。

### Java 抽象类

- 抽象类不能被实例化
- 一个类只能继承一个抽象类
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类
- 抽象类中的抽象方法只是声明，不能包含方法体
- 构造方法和类方法不能声明为抽象方法
- 抽象类的子类必须给出抽象类中抽象方法的具体实现，除非该子类也是抽象类
- abstract 不能与 private、static、final 或者 native 并列修饰同一方法，也就是说抽象方法必须为 public 或者 protected，缺省情况下默认为 public。

### 方法重载（overload）

重载（overloading） 是在一个类里面，方法名字相同，而参数不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表（参数的个数、类型、顺序），注意与返回类型无关，也就是说无法以返回值类型作为重载函数的区分标准。最常用的地方就是构造器的重载。虽然参数的顺序可以区分不同的函数，但是一般情况不考虑使用参数顺序进行区分。因为这样做会使代码变得难以维护。

当涉及基本类型的重载时，匹配顺序如下所示：

- char -> int -> long -> float -> double
- byte -> short -> int -> long -> float -> double

### 方法重写（override）

重写是子类对父类的允许访问的方法的实现过程进行重新编写，方法重写时必须遵守以下几点规则：

- 异常：重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常
- 参数列表：参数列表必须完全与被重写方法的相同
- 返回类型：返回类型必须完全与被重写方法的返回类型相同
- 访问权限：访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected

以下几种情况不能被重写：

- final：声明为 final 的方法不能被重写
- static：声明为 static 的方法不能被重写，但是能够被再次声明
- 无法继承：如果不能继承一个方法，则不能重写这个方法
- 构造方法：构造方法不能被重写

