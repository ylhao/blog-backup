---
title: 笔试：笔试题练习
categories: 编程
tags:
  - 编程
  - C++
date: 2018-07-19 14:35:31
---

## 包含题目

- 翻转整数
- Two Sum
- Two Sum II 输入的数组有序
- Search Insert Position，二分查找的模板，如果没找到，返回插入位置
- 3 Sum
- Combination Sum，多数之和等于给定集的集合，每个数字可以用多次，但是数组中没有重复元素
- Combination Sum II，数组中有重复元素，并且一个元素只能用一次。
- 树的先序遍历
- 树的中序遍历
- 树的后序遍历
- 树的层次遍历
- 树的层次遍历，与上一个题是一样的，只不过需要将输出结果逆序而已。
- 树的层次遍历，之字形打印
- 二叉树最后一行最左边的节点的值，513. Find Bottom Left Tree Value
- 找出二叉树每一层的最大值
- 特殊树中的第二小元素，671. Second Minimum Node In a Binary Tree
- 左叶子节点求和，404. Sum of Left Leaves
- 最大的二叉树，654. Maximum Binary Tree
- 二叉搜索树中两节点的最低公共子节点，235. Lowest Common Ancestor of a Binary Search Tree
- 两节点的最低公共节点，236.Lowest Common Ancestor of a Binary Tree
- 合并两个二叉树，617.Merge Two Binary Trees
- 二叉树的坡度
- 二叉树的下一个节点
- 路径和(一)——是否存在二叉树路径和等于给定值（根节点到叶子节点），112. Path Sum
- 找到所有从根节点到叶子结点的路径和为sum的路径，113. Path Sum II
- 二叉树路径和，从根节点到任意一个节点之间的和等于给定值的路径数，Path Sum III
- 树中所有从根节点到叶子节点的路径，257. Binary Tree Paths
- 所有路径代表的数字求和，129. Sum Root to Leaf Numbers
- 对称的二叉树，101. Symmetric Tree
- 翻转二叉树，226. Invert Binary Tree
- 二叉树最远两节点之间的距离

- 字符串全排列（字符串中没有重复字符），46. Permutations
- 字符串全排列（有重复字符），47. Permutations II
- 下一个全排列，31. Next Permutation

- 求一个数组的全部子集（数组中没有重复元素），78. Subsets
- 求一个数组的全部子集（数组中有重复元素），90. Subsets II

## 经典题目

- 大数相乘
- 阿里：n个节点的完全图中任意两节点间经过m条路径的最短路径
- 深信服：六一儿童节
- 深信服：三个数的最大乘积
- 快速排序实现
- 数组中的最长山脉
- 数组中的最长山谷
- 深信服：出卷子（给一些题目，每道题目都有自己的分值，从中选出若干道，要求和为100）
- 深信服：计算围棋的气
- 深信服：翻转二进制数的比特位

## 数组、链表、栈、队列

- 括号配对
- 队列实现栈
- 最小栈
- 逆波兰表达式求值
- 翻转链表

## 动态规划

- 求两个字符串的最长公共子序列
- 给两个字符串，求最小删除几步可以让两字符串相同（与上一个题相同）
- 求两个字符串的最长公共子串
- 求子序列的个数，设有两个字符串s1和s2，具体分析见样例


## 深信服：翻转二进制数的比特位

```
#include<iostream>
using namespace std;

unsigned int reverse1(unsigned int num)
{
    //TODO:
    unsigned int ret = 0;
    for (int i = 0; i < 32; i++, num /= 2)
        ret = ret * 2 + num % 2;
    return ret;
}

unsigned int reverse2(unsigned int num) {
	unsigned int res = 0;
	for(int i = 0; i < 32; i++)
		res = res | (((1 << i) & num) << (31 - (i << 1)));
	return res;
}

int main() {
	cout << reverse1(4) << endl;
	cout << reverse2(4) << endl;
	return 0;
}
```

## 深信服：计算围棋的气

```
#include <stdio.h>
#include <string.h>
#include <bits/stdc++.h>
using namespace std;

enum color {
    NONE, WHITE, BLACK,         //棋子颜色，NONE表示未落子
};

struct weiqi {
    enum color board[19][19];   //棋盘上每个位置的落子
};

struct node {
    int x;
    int y;
    node(int xtmp, int ytmp): x(xtmp), y(ytmp) {}
};

int calc(struct weiqi *wq, int y, int x)
{
    if (wq->board[x][y] == NONE)
        return -1;
    int res = 0;
    enum color COLOR = wq->board[x][y];  // 要找的颜色
    int dirx[] = {0, 0, 1, -1};
    int diry[] = {1, -1, 0, 0};
    int visited[19][19] = {0};
    queue<node> q;
    q.push(node(x, y));  // 把起点加入队列
    while(!q.empty()) {
        node curNode = q.front();
        q.pop();
        x = curNode.x;
        y = curNode.y;
        visited[x][y] = 1;
        for(int i = 0; i < 4; i++) { // 遍历周边4个方向
            int xtmp = x + dirx[i];
            int ytmp = y + diry[i];
            if(xtmp < 0 || xtmp >= 19 || ytmp < 0 || ytmp >= 19) // 超出界限
                continue;
            if((wq -> board[xtmp][ytmp] == COLOR || wq -> board[xtmp][ytmp] == NONE) && visited[xtmp][ytmp] == false) {
                if(wq -> board[xtmp][ytmp] == NONE)
                    res++;
                if(wq -> board[xtmp][ytmp] == COLOR)
                    q.push(node(xtmp, ytmp));
                visited[xtmp][ytmp] = 1;
            }
        }
    }
    return res;
}

int input(struct weiqi *wq, int *x, int *y)
{
    int row, col;
    int ret;
    char buf[80];

    for (row = 0; row < 19; ++row) {
        if (fgets(buf, sizeof(buf), stdin) == NULL)
            return -1;
        if (strlen(buf) < 19)
            return -1;
        for (col = 0; col < 19; ++col) {
            switch (buf[col]) {
                case '0':
                    wq->board[row][col] = NONE;
                    break;
                case '1':
                    wq->board[row][col] = WHITE;
                    break;
                case '2':
                    wq->board[row][col] = BLACK;
                    break;
                default:
                    return -1;
            }
        }
    }
    ret = fscanf(stdin, "%d,%d\n", x, y);
    if (ret != 2)
        return -1;
    for (row = 0 ; row < 19; ++row) {
        for (col = 0; col < 19; ++col) {
            fprintf(stderr, "%d ", wq->board[row][col]);
        }
        fprintf(stderr, "\n");
    }
    fprintf(stderr, "x = %d, y = %d\n", *x, *y);
    return 0;
}

int main()
{
    struct weiqi wq;
    int x = 0, y = 0;
    int cnt;

    memset(&wq, 0, sizeof(wq));
    if (input(&wq, &x, &y) < 0) {
        fprintf(stderr, "error!\n");
        return 1;
    }
    cnt = calc(&wq, x, y);

    printf("%d\n", cnt);
    return 0;
}
```

## 深信服：出卷子（若干数和为100）

```
#include<bits/stdc++.h>
using namespace std;

 void nsum(vector<int> &scores, vector<int> &res, vector<int> &tmp, int n, int sum) {
    if(sum == 100) {
        res.assign(tmp.begin(), tmp.end());
        return;
    }
    if(n >= scores.size())
        return;
    tmp.push_back(n + 1);  // 要这个题，累加这个题的分数，递归求解下一题
    nsum(scores, res, tmp, n + 1, sum + scores[n]);
    tmp.pop_back();  // 不要这个题，不累加这个题的得分，递归求解下一题
    nsum(scores, res, tmp, n + 1, sum);
    return;
 }

int main() {
    int num = 0;
    int temp = 0;
    cin >> num;
    vector<int> scores, res, tmp;
    for(int i = 0; i < num; i++) {
        cin >> temp;
        scores.push_back(temp);
    }
    nsum(scores, res, tmp, 0, 0);
    cout << res.size() << endl;
    for(int i = 0; i < res.size(); i++)
        cout << res[i] << endl;
}
```


## 数组中的最长山脉

```
class Solution {
public:
    int longestMountain(vector<int>& A) {
        
        int len = A.size();
        if(len < 3)
            return 0;

        int res = 0;

        for(int i = 0; i < len; i++) {

            int preLen = 1;
            int backLen = 1;

            for(int back = i; back + 1 < len; back++) {
                if(A[back + 1] < A[back]) {
                    backLen ++;
                } else {
                    break;
                }
            }

            for(int pre = i; pre - 1 >= 0; pre--) {
                if(A[pre - 1] < A[pre]) {
                    preLen ++;
                } else {
                    break;
                }
            }

            if(preLen > 1 && backLen > 1) {
                res = max(res, preLen + backLen - 1);
            }

        }
        
        return (res >= 3) ? res : 0;
    }
};
```

## 数组中的最长山谷

```
class Solution {
public:
    int longestMountain(vector<int>& A) {
        
        int len = A.size();
        if(len < 3)
            return 0;

        int res = 0;

        for(int i = 0; i < len; i++) {

            int preLen = 1;
            int backLen = 1;

            for(int back = i; back + 1 < len; back++) {
                
				// 注意最长山谷和最长山脉的区别即可
                // -------------------------
                if(A[back + 1] > A[back]) {
                // -------------------------
                    backLen ++;
                } else {
                    break;
                }
            }

            for(int pre = i; pre - 1 >= 0; pre--) {
                // -------------------------
                if(A[pre - 1] > A[pre]) {
                // -------------------------
                    preLen ++;
                } else {
                    break;
                }
            }

            if(preLen > 1 && backLen > 1) {
                res = max(res, preLen + backLen - 1);
            }

        }
        
        return (res >= 3) ? res : 0;
    }
};
```

## 快速排序实现

```
#include <iostream>
using namespace std;

int partition(int a[], int low, int high) {
    int pivot = a[low];
    int m = low;
    for(int i = low + 1; i <= high; i++) {
        if(a[i] < pivot) {  // 升序
            m ++;
            swap(a[i], a[m]);
        }
    }
    swap(a[low], a[m]);
    return m;
}

void quickSort(int a[], int low, int high) {
    if(low < high) {
        int idx = partition(a, low, high);
        quickSort(a, low, idx - 1);
        quickSort(a, idx + 1, high);
    }
}

main()
{
    int a[] = {5, 4, 2, 1, 3};
    quickSort(a, 0, 4);
    for(int i = 0; i < 5; i++)
        cout << a[i] << " ";
    return 0;
    // 输出：1 2 3 4 5
}
```

## 求子序列的个数

```
s1 = "bbcd"
s2 = "bcd"
子序列个数为 2

dp[i][j] 表示以s1[i]结尾的字符串包含以s2[j]结尾的字符串的个数
dp[i][j] = dp[i-1][j],	s1[i] ≠ s2[j]
dp[i][j] = dp[i-1][j] + dp[i-1][j-1],	s1[i] == s2[j]
```

```
class Solution {
public:
    int numDistinct(string s, string t) {
        int n1 = s.size();
        int n2 = t.size();
        if(n2 > n1)
            return 0;
        vector<vector<int>> dp (n1 + 1, vector<int>(n2 + 1, 0));
        for(int i = 0; i < n1; i++) dp[i][0] = 1;
        for(int i = 1; i <= n1; i++) {
            for(int j = 1; j <= n2; j++) {
                if(s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n1][n2];
    }
};
```

## 求两个字符串的最长公共子串

```
dp[i][j] 表示以s1[i]结尾和s2[j]结尾的最长公共子序列的长度
dp[i][j] = dp[i-1][j-1] + 1,	s1[i] == s2[j]
dp[i][j] = 0, s1[i] ≠ s2[j] 
```

## 求两个字符串的最长公共子序列
```
dp[i][j] 表示以s1[i]结尾和s2[j]结尾的最长公共子序列的长度
dp[i][j] = dp[i-1][j-1] + 1,	s1[i] == s2[j]
dp[i][j] = max(dp[i-1][j], dp[i][j-1]), s1[i] ≠ s2[j]

eg: sea eat
  0 1 2 3 
0 0 0 0 0
1 0
2 0
3 0
```

```
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n1 = A.size();
        int n2 = B.size();
        int maxlen = 0;
        vector<vector<int>> dp (n1 + 1, vector<int>(n2 + 1, 0));
        for(int i=1;i<=n1;++i)
        {
            for(int j=1;j<=n2;++j)
            {
                if(A[i-1] == B[j-1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if(dp[i][j] > maxlen)
                        maxlen = dp[i][j];
                } 
            }
        }
        return maxlen;
    }
};
```

## 求一个数组的全部子集（数组中有重复元素）

```
// 递推法
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> temp;
        res.push_back(temp);
        if(nums.empty()) return res;
        sort(nums.begin(), nums.end());  // 排序
        int last = nums[0];
        int size = 1;
        for(int i = 0; i < nums.size(); i++) {
            if(last != nums[i]) {
                last = nums[i];
                size = res.size();
            }
            int newSize = res.size();
            for(int j = newSize - size; j < newSize; j++) {
                vector<int> temp (res[j]);
                temp.push_back(nums[i]);
                res.push_back(temp);
            }
        }
        return res; 
    }
};

// 递归法
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> temp;
        sort(nums.begin(), nums.end());
        subsetsWithDupCore(res, temp, nums, 0);
        return res; 
    }
    
private:
    void subsetsWithDupCore(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int start) {
        res.push_back(temp);
        for(int i = start; i < nums.size(); i++) {
            temp.push_back(nums[i]);
            subsetsWithDupCore(res, temp, nums, i + 1);
            temp.pop_back();
            while (i + 1 < nums.size() && nums[i] == nums[i + 1]) ++i;
        }
    }
};
```

## 求一个数组的全部子集，78. Subsets

```
//递推法
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> temp;
        res.push_back(temp);
        if(nums.empty()) return res;
        for(int i = 0; i < nums.size(); i++) {
            int size1 = res.size();
            for(int j = 0; j < size1; j++) {
                vector<int> temp (res[j]);
                temp.push_back(nums[i]);
                res.push_back(temp);
            }
        }
        return res;
    }
};

//递归
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> v;
        vector<vector<int>> res;
        subsetsCore(nums, v, res, 0);
        return res;
    }
private:
    void subsetsCore(vector<int>& nums, vector<int>& v, vector<vector<int>>& res, int start) {
        if(start == nums.size()) {
            res.push_back(v);
            return;            
        }
        else{
            vector<int> v2 (v);
            v2.push_back(nums[start]);
            subsetsCore(nums, v, res, start + 1);  // 不包含当前 start 位置的元素
            subsetsCore(nums, v2, res, start + 1);  // 包含当前 start 位置的元素 
        }
    }
};
```

## 下一个全排列

```
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        int i = len - 2;
        while(i >= 0 && nums[i] >= nums[i+1]) i--;  // 从右到左找到第一个递减的数
        if(i < 0) {
            sort(nums.begin(), nums.end());
            return;
        }
        int j = i + 1;
        while(j < len && nums[j] > nums[i]) j++;
        j--;
        swap(nums[i], nums[j]);
        sort(nums.begin() + i + 1, nums.end());
    }
};
```

## 字符串全排列（字符串中没有重复字符）

```
// 交换法
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        premuteCore(res, nums, 0);
        return res;
    }
private:
    void premuteCore(vector<vector<int>>& res,vector<int>& nums, int start) {
        if(start == nums.size()) {
            vector<int> temp (nums);
            res.push_back(temp);
            return;
        } else {
            for(int i = start; i < nums.size(); i++) {
                swap(nums[i], nums[start]);  // 交换当前序列的第一个字符和后面的每个字符（包括自身）
                premuteCore(res, nums, start + 1);
                swap(nums[i], nums[start]);  // 回溯
            }
        }
    }
};
```

## 字符串全排列（有重复字符）

```
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
        permuteUinqueCore(res, nums, 0);
        return res;
    }
private:
    void permuteUinqueCore(vector<vector<int>>& res, vector<int>& nums, int start) {
        if(start == nums.size()) {
            res.push_back(nums);
            return;
        } else {
            for(int i = start; i < nums.size(); ++i) {
                //======  [start, i) 之间不能再有 nums[i]，因为有的话说明已经交换过相同的字符了
                int j = i - 1;
                while(j >= start && nums[j] != nums[i]) j--;
                if(i == start || j == start - 1) {
                //======
                    swap(nums[i], nums[start]);
                    permuteUinqueCore(res, nums, start + 1);
                    swap(nums[i], nums[start]);
                }
            }
        }
            
    }    
};
```

## 二叉树最远两节点之间的距离

543. Diameter of Binary Tree

```
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int maxlen = 0;
        diameterOfBinaryTreeCore(root, maxlen);
        return maxlen;
    }
private:
    int diameterOfBinaryTreeCore(TreeNode* root, int& maxlen) {
        if(root == NULL) return 0;
        int left = diameterOfBinaryTreeCore(root -> left, maxlen);
        int right = diameterOfBinaryTreeCore(root -> right, maxlen);
        if(left + right > maxlen) maxlen = left + right;
        return (left > right) ? left + 1 : right + 1;
    }
};
```

## 二叉搜索树中两节点的最低公共子节点

235. Lowest Common Ancestor of a Binary Search Tree

```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL) return root;
        if(p->val <root->val && q->val >= root->val || p->val >= root->val && q->val <= root->val) return root;
        else if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else
            return lowestCommonAncestor(root->right, p, q);
    }
};
```

## 翻转链表

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
		//------
        ListNode* pReverseHead = NULL;  // 翻转后的链表头
        ListNode* pPrev = NULL;  // 上一个节点
        ListNode* pCur = head;  // 当前节点
        ListNode* pNext = NULL;  // 下一个节点
        //------

        while(pCur) {
            
            pNext = pCur -> next;
            
            if(!pNext)
                pReverseHead = pCur;
            
            pCur -> next = pPrev;
            pPrev = pCur;
            pCur= pNext;
        }
        
        return pReverseHead;
        
    }
};
```

## 三个数的最大乘积

给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1) 

```
# include<bits/stdc++.h>
# include<climits>
using namespace std;

long long solve(vector<int> nums) {
    long long max1=INT_MIN, max2=INT_MIN, max3=INT_MIN;
    long long min1=INT_MAX, min2=INT_MAX;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] > max1){
            max3 = max2;
            max2 = max1;
            max1 = nums[i];
        }
        else if(nums[i] > max2) {
            max3 = max2;
            max2 = nums[i];
        }
        else if(nums[i] > max3) {
            max3 = nums[i];
        }
        if(nums[i] < min1) {
            min2 = min1;
            min1 = nums[i];
        }
        else if(nums[i] < min2) {
            min2 = nums[i];
        }
    }
    long long temp1 = max1 * max2 * max3;
    long long temp2 = min1 * min2 * max1;
    return (temp1 > temp2) ? temp1 : temp2;
}

int main() {
    int num;
    vector<int> nums;
    cin >> num;
    int temp = 0;
    for(int i = 0; i < num; i++) {
        cin >> temp;
        nums.push_back(temp);
    }
    cout << solve(nums) << endl;
    return 0;
}
```

## 六一儿童节

六一儿童节，老师带了很多好吃的巧克力到幼儿园。每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]>=h[i])，他才会上去表演节目。老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。可以保证每个w[i]> 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。

```
输入：
第一行：n，表示h数组元素个数
第二行：n个h数组元素
第三行：m，表示w数组元素个数
第四行：m个w数组元素

输出：
上台表演学生人数
```

```
#include<bits/stdc++.h>
using namespace std;

void solve(vector<int> &h, vector<int> &w) {
    sort(h.begin(), h.end());
    sort(w.begin(), w.end());
    int i = 0, j = 0, res = 0;
    while(i < h.size() && j < w.size()) {
        if(w[j] >= h[i]) {
            res++;
            i++;
            j++;
        } else {
            j++;
        }
    }
    cout << res << endl;
}

int main() {
    int numh, numw;
    vector<int> h, w;
    int temp = 0;
    cin >> numh;
    for(int i = 0; i < numh; i++) {
        cin >> temp;
        h.push_back(temp);
    }
    cin >> numw;
    for(int i = 0; i < numw; i++) {
        cin >> temp;
        w.push_back(temp);
    }
    solve(h, w);
}
```

## n个节点的完全图中任意两节点间经过m条路径的最短路径

光明小学的小朋友们要举行一年一度的接力跑大赛了，但是小朋友们却遇到了一个难题：设计接力跑大赛的线路，你能帮助他们完成这项工作么？
光明小学可以抽象成一张有N个节点的图，每两点间都有一条道路相连。光明小学的每个班都有M个学生，所以你要为他们设计出一条恰好经过M条边的路径。
光明小学的小朋友们希望全盘考虑所有的因素，所以你需要把任意两点间经过M条边的最短路径的距离输出出来以供参考。

你需要设计这样一个函数：
res[][] Solve( N, M, map[][]);
注意：map必然是N * N的二维数组，且map[i][j] == map[j][i]，map[i][i] == 0，-1e8 <= map[i][j] <= 1e8。（道路全部是无向边，无自环）2 <= N <= 100, 2 <= M <= 1e6。要求时间复杂度控制在O(N^3*log(M))。

map数组表示了一张稠密图，其中任意两个不同节点i,j间都有一条边，边的长度为map[i][j]。N表示其中的节点数。
你要返回的数组也必然是一个N * N的二维数组，表示从i出发走到j，经过M条边的最短路径。
你的路径中应考虑包含重复边的情况。

```
样例：
N = 3
M = 2
map = {
 {0, 2, 3},
 {2, 0, 1},
 {3, 1, 0}
}

输出结果result为：
result = {
 {4, 4, 3},
 {4, 2, 5},
 {3, 5, 2}
}

 

输入样例：
3
2
0 2 3
2 0 1
3 1 0

输出样例：

[[4, 4, 3],
[4, 2, 5],
[3, 5, 2]]
```

```
#include<bits/stdc++.h>
using namespace std;

void solve(vector<vector<int> >& map, vector<vector<int> >& res, int m, int n) {
    vector<vector<int> > resTmp (map);
    for(int k = 0; k < m - 1; k++) {
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                vector<int> tmp;
                for(int x = 0; x < n; x++) {
                    if(x != i && x != j) {
                        tmp.push_back(resTmp[i][x] + map[x][j]);
                    }
                }
                res[i][j] = *min_element(tmp.begin(), tmp.end());
            }
        }
        for(int ax = 0; ax < n; ax++)
            for(int ay = 0; ay < n; ay++)
                resTmp[ax][ay] = res[ax][ay];
    }
}

int main() {
    int m, n;
    cin >> n;  // n 维对称矩阵
    cin >> m;  // m 条边
    vector<vector<int> > map (n, vector<int>(n, 0));
    int temp = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cin >> temp;
            map[i][j] = temp;
        }
    }
    vector<vector<int> > res (map);
    solve(map, res, m, n);
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++)
            cout << res[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

## 逆波兰表达式求值

150. Evaluate Reverse Polish Notation

```
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for(int i = 0; i < tokens.size(); i++) {
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                int tmp1 = st.top();
                st.pop();
                int tmp2 = st.top();
                st.pop();
                
                int tmp = 0;
                
                if(tokens[i] == "+") {
                    tmp = tmp1 + tmp2;
                } else if(tokens[i] == "-") {
                    tmp = tmp2 - tmp1;
                } else if(tokens[i] == "*") {
                    tmp = tmp1 * tmp2;
                } else {
                    tmp = tmp2 / tmp1;
                }
                
                st.push(tmp);
            } else {
                st.push(stoi(tokens[i]));
            }
        }
        return st.top();
    }
};
```

## 最小栈

155. Min Stack

```
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> s1;
    stack<int> s2;  // 保存当前最小值
    MinStack() {
        
    }
    
    void push(int x) {
        if(s1.empty()) {
            s1.push(x);
            s2.push(x);
        } else {
            s1.push(x);
            if(x < s2.top())
                s2.push(x);
            else
                s2.push(s2.top());
        }
    }
    
    void pop() {
        s1.pop();
        s2.pop();
    }
    
    int top() {
        return s1.top();
    }
    
    int getMin() {
        return s2.top();
    }
};

## 队列实现栈

```
class MyStack {
public:
    queue<int> q;
    /** Initialize your data structure here. */
    MyStack() {
        
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
        
        //---------------------
        // 除了刚刚最新入队的元素，其他元素重新入队即可
        for(int i = 1; i < q.size(); i++) {
            q.push(q.front());
            q.pop();
        }
        //---------------------
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int val = q.front();
        q.pop();
        return val;
    }
    
    /** Get the top element. */
    int top() {
        return q.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * bool param_4 = obj.empty();
 */
```

## 括号配对

20. Valid Parentheses 

```
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == '(' || s[i] == '[' || s[i] == '{')
                st.push(s[i]);
            else {
                if(st.empty())
                    return false;
                else {
                    char tmp = st.top();
                    st.pop();
                    if( (s[i] == ')' && tmp != '(') || (s[i] == ']' && tmp != '[') || (s[i] == '}' && tmp != '{'))
                        return false;
                }
            }
        }
        if(st.empty())
            return true;
        else 
            return false;
    }
};
```

## 翻转整数

```
class Solution {
public:
    int reverse(int x) {
        long long r = 0;
        while(x != 0) {
            r = r * 10 + x % 10;
            x /= 10;
        }
        if(r < INT_MIN || r > INT_MAX) r = 0;
        return r;
    }
};
```

## Two Sum

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        if(nums.size() <= 1) return res;
        unordered_map<int, int> h;
        for(int i = 0; i < nums.size(); i++)
            h[nums[i]] = i;
        int tmp = 0;
        for(int i = 0; i < nums.size(); i++) {
            tmp = target - nums[i];
            if(h.count(tmp) && h[tmp] != i) {  // 不能是自身如 3 + 3 = 6
                res.push_back(i);
                res.push_back(h[tmp]);
                break;
            }
        }
        return res;
    }
};
```

## Two Sum II 输入的数组有序

```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res;
        if(numbers.size() <= 1) return res;
        int i = 0, j = numbers.size() - 1;
        while(i < j) {
            int sum = numbers[i] + numbers[j];
            if(sum == target) {
                res.push_back(i + 1);
                res.push_back(j + 1);
                break; // 只需要找一组
            } else if(sum > target) {
                j --;
            } else {
                i ++;
            }
        }
        return res;
    }
};
```

## Search Insert Position

二分查找的模板，如果没找到，返回插入位置

```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low = 0;
        int high = nums.size() - 1;
        while(low <= high) {
            int mid = low + (high - low) / 2;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
		//后来经过分析这两个边界条件判断可以不用
        //if(high < 0) return 0;
        //if(low >= nums.size()) return nums.size();
        return high + 1;
    }
};
```

## 3 Sum

三数之和为0

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int> > res;
        if(nums.size() <= 2) return res;
        sort(nums.begin(), nums.end());
        for(int k = 0; k < nums.size(); k++) {
            
            //-------------------------------------
            // 要注意去重，最开始忽略了
            if(k > 0 && nums[k] == nums[k - 1])
                continue;
            //-------------------------------------
            
             int i = k + 1, j = nums.size() - 1;
            
            int target = -nums[k];
            while(i < j) {
                int sum = nums[i] + nums[j];
                if(sum == target) {
                    vector<int> tmp;
                    tmp.push_back(nums[k]);
                    tmp.push_back(nums[i]);
                    tmp.push_back(nums[j]);
                    res.push_back(tmp);
                    //-------------------------------------
                    while(i < j && nums[i + 1] == nums[i]) i ++;
                    while(i < j && nums[j - 1] == nums[j]) j --;
                    //-------------------------------------
                    i ++;
                    j --;
                } else if(sum > target) {
                    j --;
                } else {
                    i ++;
                }
            }
        }
        return res;
    }
    
};
```

## 39. Combination Sum

多数之和等于给定集的集合，每个数字可以用多次，但是数组中没有重复元素

```
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int> > res;
        vector<int> tmp;
        solve(candidates, res, tmp, 0, target);
        return res;
    }
    
    void solve(vector<int>& candidates, vector<vector<int> >& res, vector<int>& tmp, int start, int target) {
        if(target < 0)
            return;
        if(target == 0) {
            vector<int> tmp1 (tmp);
            res.push_back(tmp1);
            return;
        }
        for(int i = start; i < candidates.size(); i++) {
            tmp.push_back(candidates[i]);
            // ----------------------------------------------------/
            // 注意为 i：表示之搜索当前的数和之后的数
            solve(candidates, res, tmp, i, target - candidates[i]);
            // ----------------------------------------------------
            tmp.pop_back();
        }
    }
};
```

## 40. Combination Sum II

数组中有重复元素，并且一个元素只能用一次。 

```
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int> > res;
        vector<int> tmp;
        sort(candidates.begin(), candidates.end());
        solve(candidates, tmp, res, 0, target);
        return res;
    }
    
    void solve(vector<int>& candidates, vector<int>& tmp, vector<vector<int> >& res, int start, int target) {
        if(target < 0)
            return;
        if(target == 0) {
            vector<int>& tmp1 (tmp);
            res.push_back(tmp1);
            return;
        }
        for(int i = start; i < candidates.size(); i++) {
            
            // 这里需要去重
            // ---------
            if(i > start && candidates[i] == candidates[i - 1]) continue;
            // ---------
            
            tmp.push_back(candidates[i]);
            solve(candidates, tmp, res, i + 1, target - candidates[i]);
            tmp.pop_back();
        }
    }
};
```

## 树的先序遍历

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == NULL)
            return res;
        stack<TreeNode*> s;
        
        s.push(root); // 根节点入栈
        
        while(!s.empty()) {
            
            // 根节点出栈，并保存根节点
            TreeNode* tmp = s.top();
            s.pop();
            res.push_back(tmp -> val);
            
            // 右子树根节点入栈
            if(tmp -> right != NULL)
                s.push(tmp -> right);
            
            // 左子树根节点入栈
            if(tmp -> left != NULL)
                s.push(tmp -> left);
            
        }
        return res;
    }
};
```

## 中序遍历 

94. Binary Tree Inorder Traversal

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return res;
        stack<TreeNode*> s;
        
        TreeNode* cur = root;
        while(!s.empty() || cur != NULL) {
            
            while(cur != NULL) {
                s.push(cur);
                cur = cur -> left;
            }
            
            cur = s.top();
            res.push_back(cur -> val);
            s.pop();
            
            cur = cur -> right;
            
        }
        
        return res;
    }
};
```

## 后序遍历

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == NULL)
            return res;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            
            TreeNode* cur = s.top();
            s.pop();
            res.push_back(cur -> val);
            
            
            if(cur -> left)
                s.push(cur -> left);
            if(cur -> right)
                s.push(cur -> right);
        }
        
        reverse(res.begin(), res.end());
        return res;
    }
};
```

## 层次遍历

102. Binary Tree Level Order Traversal

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL) return res;
        queue<TreeNode*> q;
        int curLevelNum = 1;
        int nextLevelNum = 0;
        q.push(root);
        vector<int> tmp;
        while(curLevelNum > 0) {
            TreeNode* cur = q.front();
            q.pop();
            curLevelNum --;
            tmp.push_back(cur -> val);
            
            if(cur -> left) {
                q.push(cur -> left);
                nextLevelNum ++;
            }
            
            if(cur -> right) {
                q.push(cur -> right);
                nextLevelNum ++;
            }
            
            if(curLevelNum == 0) {
                curLevelNum = nextLevelNum;
                nextLevelNum = 0;
                vector<int> tmp1 (tmp);
                tmp.clear();
                res.push_back(tmp1);
            }
        }    
        return res;
    }
};
```

## 层次遍历

与上一个题是一样的，只不过需要将输出结果逆序而已。

107. Binary Tree Level Order Traversal II

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL) return res;
        queue<TreeNode*> q;
        int curLevelNum = 1;
        int nextLevelNum = 0;
        q.push(root);
        vector<int> tmp;
        while(curLevelNum > 0) {
            TreeNode* cur = q.front();
            q.pop();
            curLevelNum --;
            tmp.push_back(cur -> val);

            if(cur -> left) {
                q.push(cur -> left);
                nextLevelNum ++;
            }

            if(cur -> right) {
                q.push(cur -> right);
                nextLevelNum ++;
            }

            if(curLevelNum == 0) {
                curLevelNum = nextLevelNum;
                nextLevelNum = 0;
                vector<int> tmp1 (tmp);
                tmp.clear();
                res.push_back(tmp1);
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

## 层次遍历

之字形打印，107. Binary Tree Level Order Traversal II


```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL) return res;
        queue<TreeNode*> q;
        int curLevelNum = 1;
        int nextLevelNum = 0;
        q.push(root);
        vector<int> tmp;
        while(curLevelNum > 0) {
            TreeNode* cur = q.front();
            q.pop();
            curLevelNum --;
            tmp.push_back(cur -> val);

            if(cur -> left) {
                q.push(cur -> left);
                nextLevelNum ++;
            }

            if(cur -> right) {
                q.push(cur -> right);
                nextLevelNum ++;
            }

            if(curLevelNum == 0) {
                curLevelNum = nextLevelNum;
                nextLevelNum = 0;
                vector<int> tmp1 (tmp);
                tmp.clear();
                res.push_back(tmp1);
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

## 二叉树最后一行最左边的节点的值

513. Find Bottom Left Tree Value

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        int res = 0;
        int maxDepth = 0;
        solve(root, 1, maxDepth, res);
        return res;
    }
    
    void solve(TreeNode* root, int depth, int& maxDepth, int& res) {
        
        // 找一棵二叉树最下面的最左边的一个节点
        
        // 先序遍历第一次遍历到新的一层时，必然是该层的最左边的节点
        
        // 所以整体是先序遍历的结构
        
        // -------------------
        if(!root)
            return;
        
        if(depth > maxDepth) {
            res = root -> val;
            maxDepth = depth;
        }
        // -------------------
        
        solve(root -> left, depth + 1, maxDepth, res);
        solve(root -> right, depth + 1, maxDepth, res);
        
    }
};
```

## 找出二叉树每一层的最大值

[515. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/)

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return res;
        queue<TreeNode*> q;
        q.push(root);
        int curLevelNum = 1;
        int nextLevelNum = 0;
        
        int maxNum = INT_MIN;
        while(curLevelNum > 0) {
            TreeNode* cur = q.front();
            q.pop();
            curLevelNum --;
            
            if(cur -> val > maxNum) {
                maxNum = cur -> val;
            }
            
            if(cur -> left) {
                q.push(cur -> left);
                nextLevelNum ++;
            }
            
            if(cur -> right) {
                q.push(cur -> right);
                nextLevelNum ++;
            }
            
            if(curLevelNum == 0) {
                curLevelNum = nextLevelNum;
                nextLevelNum = 0;
                res.push_back(maxNum);
                maxNum = INT_MIN;
            }
            
        }
        return res;
    }
};
```

## 特殊树中的第二小元素

671. Second Minimum Node In a Binary Tree

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        
        // 这个题要抓住根节点一定小于子节点这个特点
        
        if(root == NULL) return 0;
        queue<TreeNode*> q;
        int first = root -> val;
        int second = INT_MAX;
        q.push(root);
        while(!q.empty()) {
            TreeNode* cur = q.front();
            q.pop();
            
            // --------------------------------------------
            if(cur -> val != first && cur -> val < second) {
                second = cur -> val;
            }
            // --------------------------------------------
            
            if(cur -> left) q.push(cur -> left);
            if(cur -> right) q.push(cur -> right);
        }
        return (second == INT_MAX) ? -1 : second;
    }
};
```

## 左叶子节点求和

这个题也可以用队列来解

404. Sum of Left Leaves

```
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int res = 0;
        solve(root, res);
        return res;
    }
    
    void solve(TreeNode* root, int& res) {
        if(root == NULL)
            return;
        
        // -------------------------------
        
        // 递归的写法，这里最开始漏掉了一个条件，左右子树都为空才叫叶子节点
        
        if(root -> left && !root -> left -> left && !root ->left -> right) { 
        // -------------------------------
            
             // 判断是不是左叶节点
            res += root -> left -> val;
            solve(root -> right, res);
        
        } else {
        
            solve(root -> left, res);
            solve(root -> right, res);
        }
    }
};
```

## 最大的二叉树

654. Maximum Binary Tree

```
class Solution {
public:
    
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        
        TreeNode* root = constructCore(nums, 0, nums.size() - 1);
        return root;
            
    }
    
    TreeNode* constructCore(vector<int>& nums, int start, int end) {
        
        // 别忘记递归出口，忘记递归出口，运行超时
        // -----------------
        if(start > end)
            return NULL;
        // -----------------
        int pos = findMaxPos(nums, start, end);
        
        // new
        TreeNode* root = new TreeNode(nums[pos]);
        root -> left = constructCore(nums, start, pos - 1);
        root -> right = constructCore(nums, pos + 1, end);
        return root;
        
    }
    
    int findMaxPos(vector<int>& nums, int start, int end) {
        
        int maxNum = INT_MIN;
        int pos = -1;
        
        for(int i = start; i <= end; i++) {
            if(nums[i] > maxNum) {
                maxNum = nums[i];
                pos = i;
            }   
        }
        
        return pos;
    }
};
```

## 两节点的最低公共节点

236. Lowest Common Ancestor of a Binary Tree

```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        //-------------------
        if(root == NULL || root == p || root == q)
            return root;
        //-------------------
        
        TreeNode* left = lowestCommonAncestor(root -> left, p, q);
        TreeNode* right = lowestCommonAncestor(root -> right, p, q);
        
        if(left && right)
            return root;
        
        //-------------------
        if(left)  // 最低公共节点在左子树上，返回最低公共节点
            return left;
        else  // 最低公共节点在右子树上，返回最低公共节点
            return right;
        //-------------------
    }
};
```

## 合并两个二叉树

617. Merge Two Binary Trees

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        
        if(!t1 && !t2)
            return NULL;
        
        TreeNode* root = NULL;
        
        if(t1 && t2) {
            
            root = new TreeNode(t1 -> val + t2 -> val);
            root -> left = mergeTrees(t1 -> left, t2 -> left);
            root -> right = mergeTrees(t1 -> right, t2 -> right);
            
        
        }
        else if(t1 && !t2) {
            
            root = new TreeNode(t1 -> val);
            root -> left = mergeTrees(t1 -> left, NULL);
            root -> right = mergeTrees(t1 -> right, NULL);
            
        }
        
        else if(!t1 && t2) {
            
            root = new TreeNode(t2 -> val);
            root -> left = mergeTrees(NULL, t2 -> left);
            root -> right = mergeTrees(NULL, t2 -> right);
            
        }
        
        
        return root;
        
    }
};
```

## 二叉树的坡度

```
class Solution {
public:
    
    int res = 0;
    
    int solve(TreeNode* root) {
        
        if(!root)
            return 0;
        
        int left = 0,right = 0;
        left += solve(root -> left);
        right += solve(root ->right);
        
        int tmp = left - right;
        res += (tmp > 0) ? tmp : -tmp;
        
        // 注意是求和，所以要返回当前节点的值 + 左右子树的和
        //-------------------
        return root -> val + left + right;
        //-------------------
    }
    
    int findTilt(TreeNode* root) {
        solve(root);
        return res;
    }
    
    
};
```

## 二叉树的下一个节点

假设有指向父节点的指针。

```
// 乱入一波 Java~，先知道思想即可
public class Solution {
    TreeLinkNode GetNext(TreeLinkNode node)
    {
        if(node==null) return null;
        if(node.right!=null){    //如果有右子树，则找右子树的最左节点
            node = node.right;
            while(node.left!=null) node = node.left;
            return node;
        }
        while(node.next!=null){ //没右子树，则找第一个当前节点是父节点左孩子的节点
            if(node.next.left==node) return node.next;
            node = node.next;
        }
        return null;   //退到了根节点仍没找到，则返回null
    }
}
```

## 路径和(一)-是否存在二叉树路径和等于给定值（根节点到叶子节点）

112. Path Sum

```
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        
        if(!root) {
            return false;
        }
        
        // 首先得是叶子节点，注意最后一个条件不应该是 sum == 0
        //---------------------------------------------
        if(!root -> left && !root -> right && sum == root -> val)
            return true;
         //---------------------------------------------
        
        bool left = false, right = false;
        
        if(root -> left)
            left = hasPathSum(root -> left, sum - root -> val);
        if(root -> right)
            right = hasPathSum(root -> right, sum - root -> val);
        
        return left || right;
    }
};
```

## 找到所有从根节点到叶子结点的路径和为sum的路径

113. Path Sum II

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        
        vector<vector<int> > res;
        
        if(!root)
            return res;
        
        vector<int> path;
        helper(root, 0, sum, res, path);
        return res;
    }
    
    void helper(TreeNode* root, int sum, int target, vector<vector<int> >& res, vector<int>& path) {
        
        if(!root)
            return;
        
        sum += root -> val;
        
        path.push_back(root -> val);
        
        if(!root -> left && !root -> right && sum == target) {
            vector<int> tmp (path);
            res.push_back(tmp);
        }
  
        helper(root -> left, sum, target, res, path);
        helper(root -> right, sum, target, res, path);
        
        path.pop_back();
    }
};
```
## 二叉树路径和，任意两节点

437 Path Sum III

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    int pathSum(TreeNode* root, int sum) {
        
        if(!root)
            return 0;
        
        // 把左右节点重新看做一个根节点
        return helper(root, 0, sum) + pathSum(root -> left, sum) + pathSum(root -> right, sum);
        
    }
    
    int helper(TreeNode* root, int sum, int target) {
        
        if(!root)
            return 0;
        
        int res = 0;
        sum += root -> val;
        if(sum == target)
            res ++;
        
        res += helper(root -> left, sum, target) + helper(root -> right, sum, target);
        
        return res;
    }
};
```

## 树中所有从根节点到叶子节点的路径

257. Binary Tree Paths

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        if(!root)
            return res;
        helper(root, res, to_string(root->val) + "");
        return res;
    }
    
    void helper(TreeNode* root, vector<string>& res, string path) {
        
        // if(!root)
            // return;
        
        if(!root -> left && !root -> right) {
            res.push_back(path);
        }
        
        if(root -> left)
            helper(root->left, res, path + "->" + to_string(root->left->val));
        
        if(root -> right)
        helper(root->right, res, path + "->" + to_string(root->right->val));
    }
};
```

## 所有路径代表的数字求和

129. Sum Root to Leaf Numbers

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        if(!root)
            return 0;
        
        int sum = 0;
        helper(root, root -> val, sum);
        return sum;
    }
    
    void helper(TreeNode* root, int num, int& sum) {
        
        if(!root->left && !root->right)
            sum += num;
            
        if(root -> left)
            helper(root -> left, num * 10 + root-> left -> val, sum);
        
        if(root -> right)
            helper(root -> right, num * 10 + root-> right -> val, sum);
        
    }
};
```

## 对称的二叉树

101. Symmetric Tree

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return helper(root, root);   
    }
    
    bool helper(TreeNode* root1, TreeNode* root2) {
        
        if(!root1 && !root2)
            return true;
        
        if(!root1 || !root2)
            return false;
        
        if(root1 -> val == root2 -> val)
            return helper(root1 -> left, root2 -> right) && helper(root1 -> right, root2 -> left);
        
        else
            return false;
        
    }
};
```

## 翻转二叉树

226. Invert Binary Tree

```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        
        helper(root);
        return root;
        
    }
    
    void helper(TreeNode* root) {
        
        if(!root)
            return;
        
        TreeNode* tmp = root -> left;
        root -> left = root -> right;
        root -> right = tmp;
        
        helper(root -> left);
        helper(root -> right);
    }
};
```

## 大数相乘

有两个用字符串表示的非常大的大整数,算出他们的乘积，也是用字符串表示。不能用系统自带的大整数类型。

```
#include<bits/stdc++.h>
using namespace std;

void solve(string s1, string s2) {
    int len1 = s1.size();
    int len2 = s2.size();
    vector<int> a, b, r(len1 + len2, 0); 
    for(int i = len1 - 1; i >= 0; i--) // 从低位到高位存储
        a.push_back(s1[i] - '0');
    for(int i = len2 - 1; i >= 0; i--) // 从低位到高位存储
        b.push_back(s2[i] - '0');
    ////////////////////////////////////////
    for(int i = 0; i < len1; i++) {
        for(int j = 0; j < len2; j++) {
            int k = i + j;
            r[k] += a[i] * b[j];
            while(r[k] > 9) {
                r[k + 1] += r[k] / 10;
                r[k] %= 10;
                k++;
            }
        }
    }
    ////////////////////////////////////////
    int i = 0;
    for(i = r.size() - 1; i >= 0; i--) {
        if(r[i] != 0) break;
    }
    for(i; i >= 0; i--) {
        cout << r[i];
    }
    cout << endl;
}

int main() {
    string c1, c2;
    cin >> c1 >> c2;
    solve(c1, c2);
    return 0;
}
```



